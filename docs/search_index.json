[["index.html", "Data Science &amp; Machine Learning Einführung", " Data Science &amp; Machine Learning Dieter Greipl 2022-03-15 Einführung Dieses Skript entstand (und entsteht) aus meinen Lehrveranstaltungen rund um das Thema Data Science &amp; Machine Learning. Die Inhalte richten sich Einsteiger und Studierende, insbesondere der Fachrichtungen Betriebswirtschaftslehre, die Schritte auf das KI-Spielfeld wagen und das Potential von datengetriebenen Lösungsverfahren verstehen wollen. Übliche Vorkenntnisse im Bereich Mathematik und Statistik werden erwartet, teilweise knapp wiederholt. Vorkenntnisse im Bereich der Programmierung sind nicht nötig, aber natürlich hilfreich. "],["python---quickstart.html", "Chapter 1 Python - Quickstart 1.1 Hallo Welt 1.2 Programme und Fehler 1.3 Python lernen", " Chapter 1 Python - Quickstart Es wird sie nicht überraschen, dass Data-Science nur mit Unterstützung eines Computers und speziellen Programmiersprachen zielführend ist. Wir verwenden hierfür die Programmiersprache Python. Ich empfehle dringend, eine der folgenden Varianten für praktische Übungen mit Python zu verwenden. Wir starten in beiden Varianten mit dem typischerweise ersten Programm für Anfänger, dem Hallo-Welt-Programm. Dieses Programm gibt lediglich den digitalen Gruß Hallo Welt in dem vorgesehen Ausgabebereich aus. 1.1 Hallo Welt Unser kleines Begrüßungsprogramm besteht nur aus einer Zeile print(&quot;Hallo Welt&quot;) Die Ausgabe dieses Programms ist: #&gt; Hallo Welt Wichtig: In den meisten Fällen zeigen wir zu Python-Programmen auch die Ausgaben. Sie starten in diesem Skript stets mit der Zeichenfolge #&gt; Variante 1: Colab-Notebooks Unter dem Link https://colab.research.google.com/ können sie ein sogenanntes Colab-Notebook erstellen. In die Programmzelle können tragen sie die Befehle ein. Ein Klick auf führt die Programmzeilen aus und schreibt eventuelle Ausgaben unter die Programmzelle. Colab-Notebook mit Programmzelle Versuchen sie es! Mit File-&gt;Save können sie das Notebook abspeichern. Weitere Hinweise zum Umgang mit Colab-Notebook finden sie unter https://research.google.com/colaboratory/faq.html. Besonders smart ist die Funktion von Textzellen. Sie erlauben das Hinzufügen eigener Texte vor oder nach den Programmzellen; so lässt sich ein eigenes Skript erstellen. Textzelle über der Programmzelle Variante 2: Installation von Python Alternativ können sie Python auch auf ihrem Rechner installieren. Die Installationsanleitung finden sie auf https://www.python.org/. Um die Installation zu prüfen verwenden sie den Befehl python --version Als Ausgabe erhalten sie die installierte Version von Python, zum Beispiel Python 3.9.6. Sie können nun mit einem einfachen Texteditor, z.B. Notepad++, die Programmbefehle in eine Datei schreiben. Wenn sie die Zeile print(\"Hallo Welt\") in die Datei HalloWelt.py schreiben, so können sie das Programm mit folgendem Befehl ausführen. python HalloWelt.py Sie sollten nun die Ausgabe Hallo Welt sehen. Verwenden sie die für Python-Programme übliche Dateiendung .py. Keine Leerzeichen im Dateinamen! 1.2 Programme und Fehler Sie werden eventuell Syntax-Fehler in ihren Programmen haben. Syntax-Fehler entstehen, wenn Python ihr Programm nicht versteht. Oft geht es dabei um Rechtschreibfehler: schreiben sie fälschlicherweise prin(\"Hallo Welt\"), so erhalten sie bei der Programmausführung eine Fehlermeldung: line 1, in &lt;module&gt; prin(&quot;Hallo Welt&quot;) NameError: name &#39;prin&#39; is not defined Häufig lässt sich diese Meldung leicht verstehen, und sie können den Fehler korrigieren. Läuft ein Programm ohne Fehlermeldung ab, so kann man daraus natürlich nicht auf die Korrektheit des Programms schließen! Ihr Programm kann auch logisch falsch sein, also nicht die gewünschte Funktion oder Berechnung ausführen. 1.3 Python lernen Es geht uns nicht in erster Linie darum gute Python-Programmierer zu werden. Unsere Kenntnisse müssen aber für Bearbeitung unserer Problemstellungen ausreichen. Das legt auch den Umfang an Python Know-How fest, den sie in dieser Unterlage finden. Es gibt hierfür zahlreiche gute Bücher und Internetquellen. Eine gutes Online-Angebot, auf das ich regelmäßig verweisen werde ist https://www.w3schools.com/python/. Suchen sie doch unter Python Intro nach dem Hallo-Welt-Beispiel. Sie finden dort unter Try it Yourself eine weitere Möglichkeit Python-Programme auszuführen! "],["daten.html", "Chapter 2 Daten 2.1 Iris-Datensatz 2.2 Variablen 2.3 Datentypen 2.4 Skalenniveaus", " Chapter 2 Daten Daten1 sind Ergebnisse von Beobachtungen, Messungen oder Berechnungen, die in einer bestimmten Form notiert, sind. Häufig sprechen sprechen wir auch von Werten, statt von Daten. Wenn wir viele gleichartige Daten erfassen, aufbereiten und Zusammengänge analysieren, so lassen sich daraus möglicherweise mittels Algorithmen komplexe Aufgabenstellungen lösen. Wir erläutern diese Idee anhand des Iris-Datensatzes2 (engl. Iris flower data set). 2.1 Iris-Datensatz Der Iris-Datensatz ist einer der bekanntesten Datensätze für Maschinelles Lernen und entstand 1936. Gegenstand der Messung waren 150 Lilien der Arten Iris setosa, Iris versicolor, und Iris virginica. Gemessen wurden für je eine Blüte jeweils (in cm): die Länge und Breite des Kronblattes (Petalum, petal) sowie die Länge und Breite des Kelchblattes (Sepalum, sepal) Pro Messung entstehen also 4 Werte und die Spezies der untersuchten Lilie. Lilienarten Messung von Länge und Breite3 Nachfolgende Tabellen zeigen die Aufzeichnungen der ersten 5 Messungen gefolgt und der letzten 5 Messungen. Der Datensatz enthält jeweils 50 Lilien jeder Sorte. Die Spezies wird in der letzten Spalte unter class angegeben Die ersten 5 Datensätze (#0 - #4): #&gt; sepal_len sepal_wid petal_len petal_wid class #&gt; 0 5.1 3.5 1.4 0.2 setosa #&gt; 1 4.9 3.0 1.4 0.2 setosa #&gt; 2 4.7 3.2 1.3 0.2 setosa #&gt; 3 4.6 3.1 1.5 0.2 setosa #&gt; 4 5.0 3.6 1.4 0.2 setosa Die letzten 5 Datensätze (#145 - #149): #&gt; sepal_len sepal_wid petal_len petal_wid class #&gt; 145 6.7 3.0 5.2 2.3 virginica #&gt; 146 6.3 2.5 5.0 1.9 virginica #&gt; 147 6.5 3.0 5.2 2.0 virginica #&gt; 148 6.2 3.4 5.4 2.3 virginica #&gt; 149 5.9 3.0 5.1 1.8 virginica Wir greifen zwar etwas vor, aber an diesem Beispiel lässt sich eine typische Aufgabenstellung von Machine Learning recht einfach erklären: Ein Bobachter erhebt für die Blüte einer Lilie die Messwerte sepal_len, sepal_wid, petal_len, petal_wid und will daraus die Art dieser Lilie bestimmen. Nehmen wir nun an, dass der Beobachter die Werte \\((5.1, 3.5, 1.4, 0.2)\\) misst. Wir erkennen, dass genau diese Werte als Datenzeile \\(0\\) in unserem Datensatz vorliegen und bereits von einer Setosa erhoben wurden (Spalte class). Wir werden natürlich Setosa als Art dieser Blüte angeben. Dieser Fall wir wohl eher selten auftreten. Schwieriger ist die Antwort zum Beispiel für die Messwerte \\((6.1, 3.2, 5.3, 2.1)\\), die nicht als Zeile in unserem Datensatz auftreten. Mit etwas Recherche finden wir heraus, dass Datensatz 148 für die recht ähnlichen Werte \\((6.2, 3.4, 5.4, 2.3)\\) für eine Virginica enthält. Wir könnten also mit der Art Virginica antworten.4 Um Datensätze für Machine Learning zu verwenden, müssen wir wir sie vorher auf Tauglichkeit untersuchen, eventuell korrigieren, filtern und so weiter. 2.2 Variablen Eine Beobachtung oder Messung eines einzelnen Wertes formulieren wir in obigem Beispiel in der Form Sepal-Länge: 5,1cm. Die Beobachtung Sepal-Länge wird bei verschiedenen Blüten verschiedene Werte annehmen. Zum Umgang mit diesen Werten verwenden wie Variablen. Variablen sind Platzhalter oder Speicher für Werte, wir sprechen also vom Wert einer Variable. Im nachfolgendem Beispiel wird der Variable mit dem Namen sepal_laenge der Wert \\(5.1\\) zugewiesen. Variablen haben immer einen Namen. Einen Wert erhalten sie erst durch eine sog. Zuweisung (wie in Zeile 1). In Zeile 2 drucken wir den Wert aus. Führen Sie also folgende Phython-Befehle aus: sepal_len = 5.1 print(sepal_len) Ausgabe: #&gt; 5.1 Die erstmalige Zuweisung eines Wertes an eine Variable heißt Initialisierung. Wichtig: Leerzeichen in Variablennamen sind nicht erlaubt! (Deshalb wurde der Underscore verwendet.) Vermeiden sie Umlaute in Variablen 2.3 Datentypen Ein Wert einer Messung kann neben einer Zahl \\(5.1\\) auch ein Text (zum Beispiel sehr gut) sein. Offensichtlich gehören beide Werte zu verschiedene Typen von Werten, den sogenannten Datentypen. Zudem brauchen wir logischen Datentypen, um zu bewerten, ob Sachverhalte wahr (True) oder falsch (False) sind. Wir beschäftigen uns also mit den Datentypen Zahlen Strings (Text, Worte) und Boolean (logische Werte). Werte mit diesen Datentypen lassen sich zu Listen und Tupel zusammenfassen. Wir behandeln sie am Ende des Abschnittes. 2.3.1 Zahlen Werte dieses Datentyps sind z.B. \\(1\\), \\(-1\\), \\(1.7\\) oder \\(1/3\\). Wie sie wissen, lässt sich die Menge der Zahlen noch weiter einteilen in natürliche Zahlen und reelle Zahlen 5. Zur Notation diese Zahlenmengen verwenden wir die üblichen Symbole \\(\\mathbb{N}\\) für die natürlichen Zahlen und \\(\\mathbb{R}\\) für die reellen Zahlen. Wir notieren Zahlen wie üblich und verwenden in der Dezimalnotation den Punkt als Trennsymbol. Nachfolgendes Beispiel zeigt anhand einfacher Programmzeilen die Darstellung von Zahlen und zugleich schon die Verwendung der üblichen Operatoren für Addition und Multiplikation. x = 1 print(x) x = 1+1.1 print(x) x = 1/2+3/4 print(x) x = 1.2*2 print(x) Die Ausgabe dieses Programms ist: #&gt; 1 #&gt; 2.1 #&gt; 1.25 #&gt; 2.4 Mit der Funktion type kann lässt sich der Datentyp eines Wertes ausgeben. Es wird an einigen Stellen hilfreich sein, den Datentyp eines Wertes anzuzeigen. x = 1; print(type(x)) x = 1.2; print(type(x)) x = 4/3; print(type(x)) Die Ausgabe dieses Programms ist: #&gt; &lt;class &#39;int&#39;&gt; #&gt; &lt;class &#39;float&#39;&gt; #&gt; &lt;class &#39;float&#39;&gt; Die erste Ausgabezeile bedeutet, dass int der Datentyp des Wertes \\(1\\) ist. Analog ist float der Datentyp des Wertes \\(1.2\\). Beachten Sie, dass der Ausdruck \\(4/2\\) den Datentyp float besitzt, obwohl auch int plausibel wäre. Operationen Zahlen lassen sich verknüpfen mit den üblichen Symbolen verknüpfen. x = 9; y = -4 e = x+y print(e) e = x-y print(e) e = x*y print(e) e = x/y print(e) Die Ausgabe dieses Programms ist: #&gt; 5 #&gt; 13 #&gt; -36 #&gt; -2.25 Wir werden mit diesen Operationen zurechtkommen. Mehr finden Sie unter https://www.w3schools.com/python/python_operators.asp 2.3.2 Strings Strings sind Zeichenkette. Werte dieses Datentyps sind zum Beispiel Baum, Hans Huber oder sehr gut. Zeichenketten beginnen und enden mit einem Anführungszeichen. In der Regel macht uns diese Notationen keine Probleme - manchmal wird es trotzdem ungemütlich: Kann eine Zeichenkette ein Anführungszeichen enthalten? Gibt es einen Unterschied zwischen der Zahl 123 und der Zeichenkette 123? Wir vertiefen das hier nicht, sondern gehen auf die Fragen an, sobald sie uns begegnen. Wir können einer Variable einen String zuweisen, wenn wir den Wert in Hochkommata setzen: s = &quot;Aus&quot; print( type(s) ) Ausgabe: #&gt; &lt;class &#39;str&#39;&gt; Die einzige benötigte Operation ist die sogenannte Konkatenation, also das Aneinanderhängen von Strings. Dazu wird der \\(+\\) Operator verwendet: s = &quot;Aus&quot; t = &quot;gabe&quot; print( s+t ) Ausgabe: #&gt; Ausgabe Frage: Was erwarten sie für die Berechnung \\(s-t\\) oder \\(s*t\\) ? Mehr lesen: https://www.w3schools.com/python/gloss_python_string_concatenation.asp 2.3.3 Boolean Der Datentyp Boolean (logischer Datentyp) umfasst nur zwei Werte, die sogenannten Wahrheitswerte. Wir werden in diesem Text die Notation True und False verwenden. b = True; print(b) print( type(b) ) b = False; print(b) print( type(b) ) Ausgabe: #&gt; True #&gt; &lt;class &#39;bool&#39;&gt; #&gt; False #&gt; &lt;class &#39;bool&#39;&gt; 2.3.4 Listen und Tupel Listen und Tupel sind eine geordnete Zusammenstellung von Werten. 2.3.4.1 Listen Folgendes Beispiel illustriert den Datentype list l = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] print( l ) print( type(l)) Ausgabe: #&gt; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;] #&gt; &lt;class &#39;list&#39;&gt; Auf Element einer Liste wird durch Angabe der gewünschten Position zugegriffen l = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] print( l[0] ) print( l[2] ) Ausgabe: #&gt; apple #&gt; cherry Damit lassen sich auch Einträge der Liste ändern: l = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] l[1] = &quot;orange&quot; print( l ) Ausgabe: #&gt; [&#39;apple&#39;, &#39;orange&#39;, &#39;cherry&#39;] Die Länge einer Liste lässt sich über die eingebaute Funktion len abfragen: l = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;] print( len(l) ) Ausgabe: #&gt; 3 Tupel Tupel sind sehr ähnlich zu Listen, die Einträge sind jedoch nicht änderbar. Zur Unterscheidung gegenüber Listen werden runde Klammern verwendet: t = (&quot;Erde&quot;,-1,&quot;Mond&quot;) print(t) print( t[2] ) print( len(t) ) print( type(t) ) Ausgabe: #&gt; (&#39;Erde&#39;, -1, &#39;Mond&#39;) #&gt; Mond #&gt; 3 #&gt; &lt;class &#39;tuple&#39;&gt; Beachten sie, dass der Versuch einer Änderung durch t[0] = 1 zu einem Fehler führt (Test als Übung!). 2.3.5 Zusammenfassung Die Datentypen int, float, bool, list und tupel sind in Python eingebaut. Wir werden später weitere, kompliziertere Datentypen kennenlernen, die über Erweiterung von Python verfügbar sind. Eine komplette Aufzählung aller Datentypen finden sie unter https://www.w3schools.com/python/python_datatypes.asp. Wie sie sehen, haben wir nicht alle Varianten behandelt. Stellen sie sich jeden Datentyp als Menge vor. Die Elemente der Menge sind die zulässigen Werte des Datentyps. Offensichtlich ist besitzt die Menge der Zahlen oder Texte unendlich viele Elemente, während der Logische Datentyp nur zwei Werte kennt. 2.3.6 Übungen Geben sie die Ergebnisse der Rechnungen \\(3-1.1\\) und \\(12 / 5\\) aus. Erklären Sie die Ausgabe für folgenden Programmzeile print(1e2+1e-1) Ausgabe: #&gt; 100.1 2.4 Skalenniveaus Niveau Operationen Beschreibung Statistik/Operation Beispiel Nominal \\[=, \\neq\\] Werte haben keine natürliche Ordnung; sie beschreiben Kategorien oder Klassen Modus (Mode) München, Hamburg, Essen Ordinal \\[&lt;, &gt;\\] Werte haben eine definierte Ordnung; arithmetische Operation (z.B. Summe, Differenz, Multiplikation, Division) sind nicht definiert Definition. Median Schulnoten, Tabellenplatz in der Bundesliga Intervall \\[+,-\\] Differenzen von Werten haben identische Bedeutung, die Addition ist sinnvoll definierbar. Es gibt keinen global oder eindeutig definierten Nullpunkt Mittelwert Temperatur Ratio \\[\\cdot , /\\] Der Nullpunkt ist eindeutig definiert. (Verallgemeinerter) Mittelwert6 Alter Bemerkungen: Skalenniveaus sind nicht immer klar zuzuordnen. Auf nominalen Datenskalen lassen sich stets künstliche Ordnungen (und damit ordinale Datenskalen) definieren. Bilden sie keine Mittelwerte auf Daten mit ordinalen Datenskalen! Nominale und ordinale Datenskalen heißen auch kategorisch oder qualitativ. Intervall und Ratio-Datenskalen heißen auch metrisch. Ergänzend: Die fünf Skalenniveaus: Einfach und verständlich erklärt (statistikpsychologie.de) Beispiel: Von Nominal zu Ordinal Wir werden später folgende eindeutige Zuordnung treffen: Nominaler Wert Ordinaler Wert setosa 0 versicolor 1 virginica 2 Diese einfache Zuordnung weist auf einen wichtigen Arbeitsschritt hin: dem Auf- und Vorbereiten der Daten für die weitere Bearbeitung. 2.4.1 Übungen Welches Skalenniveau haben die einzelnen Spalten im Iris-Datensatz? Diskutieren sie die Zulässigkeit einer Durchschnittsnote für Prüfungen. "],["lineare-algebra.html", "Chapter 3 Lineare Algebra 3.1 Skalar 3.2 Vektor und Dimension 3.3 Matrix 3.4 Übungen", " Chapter 3 Lineare Algebra In diesem Abschnitt wiederholen wir ein paar ausgewählte Begriffe aus der Linearen Algebra, die bekannt sein sollten. 3.1 Skalar Die meisten Objekte der Linearen Algebra sind Strukturen von Zahlen, zum Beispiel Vektoren oder Matrizen. Skalare dagegen sind ganz einfach nur Zahlen, in unserem Fall reelle Zahlen. Wir bezeichnen Skalare mit kleinen kursiven Buchstaben. Wir schreiben zum Beispiel \\(s \\in \\mathbb{R}.\\) Wir betrachten nur reelle Vektorräume! 3.2 Vektor und Dimension Ein Vektor ist ein Tupel reeller Zahlen, die in einer bestimmten Weise angeordnet sind. Jede reelle Zahl aus dem Tupel ist über einen Index genau bestimmt. Wir notieren einen Vektor mit einem kleinen und fett gedruckten Buchstaben, also z.B. \\(\\bf{x}\\) . Die einzelnen Zahlen des Vektors werden kursiv gedruckt und mit ihrem Index notiert, also die erste Zahl mit \\(x_1\\), die zweite Zahl mit \\(x_2\\) und so weiter. Enthält der Vektor \\(n\\) reelle Zahlen so ist der Vektor ein Element des n-fachen kartesischen Produktes der reellen Zahlen \\(\\mathbb{R}\\), kurz \\(\\mathbb{R}^{n}\\). Um die Elemente eines Vektors explizit anzugeben, wird sie in der Regel als Spalte in eckigen Klammern notiert, also \\[ \\bf{x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\in \\mathbb{R}^n \\] Häufig werden wir auch die Notation in Form einer Zeile wählen also \\(\\mathbf{x} = (x_1, \\ldots, x_n)\\). Die Zahl n heißt Dimension des Vektors. 3.2.1 Multiplikation mit Skalar und elementweise Addition Für zwei Vektoren \\(\\bf{x},\\bf{y} \\in \\mathbb{R}^{n}\\) ist die Multiplikation mit einem Skalar und die Addition definiert durch: \\[ s \\cdot\\bf{ x} = \\begin{bmatrix} s\\cdot x_1 \\\\ s\\cdot x_2 \\\\ \\vdots \\\\ s\\cdot x_n \\\\ \\end{bmatrix} \\quad \\text{und}\\quad \\bf{x} + \\bf{y}= \\begin{bmatrix} x_1 + y_1 \\\\ x_2 + y_2 \\\\ \\vdots \\\\ x_n + y_n \\\\ \\end{bmatrix} \\] 3.2.2 Skalarprodukt Man kann für zwei Vektoren \\(x, y \\in \\mathbb{R}^{n}\\) gleicher Dimension ein spezielles Produkt bilden, das wir mit \\(\\langle\\bf{x},\\bf{y}\\rangle\\) notieren. (Zur Unterscheidung haben wir oben die Bezeichnung Multiplikation mit einem Skalar gewählt). Das Skalarprodukt ist definiert durch: \\[ \\langle\\bf{x},\\bf{y}\\rangle = \\sum_{i=1}^{n} x_i \\cdot y_i \\] Das Skalarprodukt ist für uns deshalb wichtig weil für n=3 der Ausdruck \\(\\sqrt{\\langle\\bf{x},\\bf{y}\\rangle}\\) die Länge eines Vektors (oder den Abstand vom Nullpunkt) im euklidischen Raum angibt (Veranschaulichen Sie sich das als Übung. 3.3 Matrix Eine (reell-wertige) Matrix ist eine zweidimensionale, in Zeilen und Spalten angeordnete Struktur von reellen Zahlen. Jedes Element einer Matrix \\(\\bf{A}\\) wird über zwei Indizes bestimmt. Wir notieren eine Matrix mit einem fett gedruckten Großbuchstaben und die Elemente der Matrix mit dem Buchstaben der Matrix, aber nun nicht-fett und kursiv gedruckt und mit zwei Indizes versehen. Besteht eine Matrix aus n Zeilen und m Spalten, so notieren wir das durch \\(\\bf{A}\\in\\mathbb{R}^{n\\times m }\\) und nennen \\(\\bf{A}\\) eine Matrix mit der Dimension n kreuz m (als mit n Zeilen und m Spalten) \\[ \\bf{A}= \\begin{bmatrix} A_{1,1} &amp; A_{1,2} &amp; \\cdots &amp; A_{1,m} \\\\ A_{2,1} &amp; A_{2,2} &amp; \\cdots &amp; A_{2,m} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ A_{n,1} &amp; A_{n,2} &amp; \\cdots &amp; A_{n,m} \\\\ \\end{bmatrix} \\] 3.3.1 Elementweise Addition Ist \\(\\bf{B} \\in\\mathbb{R}^{n\\times m }\\), also eine Matrix der gleichen Dimension, wie \\(\\bf{A}\\), so lässt sich die Summe \\(\\bf{A+B}\\) bilden durch: \\[ (A+B)_{i,j} = A_{i,j} + B_{i,j} \\] wir addieren also einfach die Elemente auf jeweiligen Positionen. 3.3.2 Multiplikation mit Skalar und Addition Die Matrix \\(\\bf{A}\\) lässt sich mit einer reellen Zahl \\(s\\) (also einem Skalar) multiplizieren und die entstehende Matrix \\(\\bf{sA}\\) ist wie erwartet definiert durch \\[ (sA)_{i,j} = s \\cdot A_{i,j} \\] wir multiplizieren also jedes Element der Matrix mit dem Skalar \\(s\\). 3.3.3 Transponieren Durch Transponieren wird aus einer Matrix \\(\\bf{A}\\in\\mathbb{R}^{n\\times m }\\) eine neue Matrix \\(\\bf{A^T} \\in\\mathbb{R}^{m\\times n }\\) erzeugt. Dabei gilt \\[ (A^T)_{j,i} = A_{i,j} \\quad \\text{für } \\quad i \\in {1,...,n} \\quad \\text{und} \\quad j \\in {1,...,m} \\] Transponieren lässt sich durch eine Art spiegeln von \\(\\bf{A}\\) an deren Hauptdiagonale verstehen. Die Hauptdiagonale ist die gedachte Linie, die vom Element \\(A_{0,0}\\) im Winkel von 45 Grad nach rechts unten verläuft. Zum Beispiel: \\[ \\bf{A} = \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\\\ \\end{bmatrix} \\in \\mathbb{R}^{3\\times 2 } \\quad\\Rightarrow\\quad \\bf{A^T} = \\begin{bmatrix} 1 &amp; 3 &amp; 5 \\\\ 2 &amp; 4 &amp; 6 \\\\ \\end{bmatrix} \\in \\mathbb{R}^{2\\times 3 } \\] 3.3.4 Matrixprodukt Wir können zwei Matrizen \\(\\bf{A}\\) und \\(\\bf{B}\\) multiplizieren, wenn die Anzahl der Zeilen in B der Anzahl der Spaten in A entspricht. Für \\(\\bf A \\in\\mathbb{R}^{n\\times m }\\) und \\(\\bf B \\in\\mathbb{R}^{m\\times p }\\) gilt für das Produkt \\(\\bf{C}= \\bf{ A} \\bf B \\in\\mathbb{R}^{n\\times p }\\) \\[ C_{i,j} = \\sum_{l=1}^m A_{i,l} B_{l,j} \\] 3.3.5 Vektoren als Matrix Da wir Vektoren grafisch in einer Spalte notiert haben, nennen wir sie auch Spaltenvektoren. Ein Spaltenvektor lässt sich offensichtlich als eine Matrix interpretieren, die nur aus einer Spalte besteht. \\[ \\bf{x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\in \\mathbb{R}^{n \\times 1} \\] Wenn wir diese Matrix, wie oben dargestellt, transponieren, entsteht eine Matrix , die nur aus einer Zeile besteht. Diese Matrix bezeichnen wir als Zeilenvektor. Die Analogie führt uns zum Konzept eines transponierten Vektors: \\[ \\bf{x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\in \\mathbb{R}^{n \\times 1} \\quad\\Rightarrow\\quad \\bf{x^T} = \\begin{bmatrix} x_1, x_2 , \\dots, x_n \\\\ \\end{bmatrix} \\in\\mathbb{R}^{1 \\times n} \\] In der Regel identifizieren wir \\(\\mathbb{R}^{n \\times 1}\\) und \\(\\mathbb{R}^{1 \\times n}\\), aber grundsätzlich besteht doch ein Unterschied. Betrachten wir \\(x,y\\) als \\(n \\times 1\\)-Matrix, so ist \\[ \\langle\\bf{x},\\bf{y}\\rangle = x^T y \\] Machen sie sich klar, dass obige Gleichheit keine Definition ist, sondern aus der Definition des Matrixproduktesfolgt! 3.4 Übungen 3.4.1 Skalarprodukt Berechnen Sie \\(\\bf{v}^T \\bf{w}\\), \\(\\bf{v}+\\bf{w}\\) und \\(2 \\cdot \\bf{v}\\) für \\[ \\bf{v} = \\begin{bmatrix} 1 \\\\ -3 \\\\ 2\\\\ \\end{bmatrix} \\quad \\text{and} \\quad \\bf{w} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 13\\\\ \\end{bmatrix} \\] 3.4.2 Matrixprodukt 1 Berechnen sie \\(A\\bf{v}\\) für \\[ A = \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\\\ 7 &amp; -1 &amp; 2 \\\\ 0 &amp; 4 &amp; -1 \\end{bmatrix} \\quad \\text{and} \\quad \\bf{v} = \\begin{bmatrix} 1 \\\\-3 \\\\ 2 \\end{bmatrix} \\] 3.4.3 Matrixprodukt 2 Berechnen Sie \\(\\bf{v}\\bf{w}^T\\) für die beiden oben angegebenen Vektoren (Vorsicht!). 3.4.4 Matrixprodukt 3 Berechnen sie \\(\\bf{A}\\bf{C}\\) für \\[ A = \\begin{bmatrix} 2 &amp; -1 \\\\ 4 &amp; 0 \\\\ 9 &amp; 3 \\end{bmatrix} \\quad\\text{und} \\quad C = \\begin{bmatrix} 1 &amp; 0 \\\\ 4 &amp; -1 \\end{bmatrix} \\] 3.4.5 Symmetriebetrachtung Zur Vertiefung: 1. Gilt für zwei Matrizen \\(\\mathbf{A,B}\\in\\mathbb{R}^{n\\times n }\\) die Gleichheit \\(\\bf{AB} = \\bf{BA}\\) Gilt für zwei Vektoren \\(x,y \\in \\mathbb{R}^n\\) die Gleichheit: \\(\\mathbf{x}^T \\mathbf{y} = \\mathbf{y}^T\\mathbf{x}\\)? "],["numpy-arrays.html", "Chapter 4 Numpy-Arrays 4.1 Wofür brauchen wir Numpy? 4.2 Numpy-Arrays 4.3 Vektor mit Numpy 4.4 Matrix mit Numpy", " Chapter 4 Numpy-Arrays 4.1 Wofür brauchen wir Numpy? Numpy ist eine Python-Library7 (Bibliothek von Funktionen) für die effiziente Erzeugung, Berechnung und Bearbeitung von Zahlenstrukturen, zum Beispiel Vektoren, Matrizen oder Tensoren. Wir werden Numpy nutzen, um die Datensätze für maschinelles Lernen zu bearbeiten. Eine umfangreiche und behutsame Einführung finden sie unter https://www.w3schools.com/python/numpy/. Wir besprechen in diesem Abschnitt nur die für unsere Inhalte relevanten Teile. Wichtig: Beginnen Sie jeden Programmblock, in dem sie numpy-Funktionen brauchen, mit der Zeile import numpy as np 4.2 Numpy-Arrays 4.3 Vektor mit Numpy Folgende Code zeigt, wie der erste Datensatz \\((5.1, 3.5, 1.4, 0.2) \\in \\mathbb{R}^4\\) aus dem Iris-Dataset als Vektor \\[ \\mathbf{x} = (5.1, 3.5, 1.4, 0.2) \\in \\mathbb{R}^4 \\] in einer Variable mit dem Namen x erzeugt wird8. 4.3.1 Beispiel import numpy as np x = np.array( [5.1, 3.5, 1.4, 0.2]) print( x ) print( type(x) ) Ausgabe: Wir sehen die Darstellung des Vektors, strukturiert über eckige Klammern und den neuen Datentyp numpy.ndarray. #&gt; [5.1 3.5 1.4 0.2] #&gt; &lt;class &#39;numpy.ndarray&#39;&gt; Wir werden sehen, dass wir den aus der Mathematik gewohnten Umgang mit Vektoren (und Matrizen) einfach in Numpy übertragen können. 4.3.2 Shape (Dimension) Das Attribut shape liefert die Dimension eines Arrays. import numpy as np x0 = np.array( [5.1, 3.5, 1.4, 0.2]) print( x0.shape ) Die Ausgabe (4,) bedeutet, dass die Struktur aus 4 Zahlen entlang einer Dimension besteht. (Das wird im nachfolgenden Abschnitt spannender.) #&gt; (4,) 4.3.3 Zugriff auf Elemente Für einen Vektor \\(\\bf{x} \\in \\mathbb{R}^n\\) nehmen wir auf die einzelnen Werte mittels \\(x = (x_1, ..., x_n)\\) durch Verwendung eines tiefgestellten Index Bezug. Für \\(\\mathbf{x} = (5.1, 3.5, 1.4, 0.2) \\in \\mathbb{R}^4\\) ist also \\(x_1 = 5.1\\). In Numpy machen wir das analog, starten die Nummerierung jedoch bei Null, wie folgendes Beispiel zeigt. Beachten sie die Analogie zu Listen in Abschnitt . import numpy as np x = np.array( [5.1, 3.5, 1.4, 0.2]) print( x[0] ) Ausgabe: #&gt; 5.1 Übung: Geben sie das letzte Element mit dem Wert 0.2 aus. 4.3.4 Werte verändern Mit der Verwendung des Index können wir einzelne Einträge auch verändern. Wir sehen behandeln dazu den Ausdruck x[0] einfach als Variable und verwenden eine Wertzuweisung. import numpy as np x = np.array( [5.1, 3.5, 1.4, 0.2]) x[0] = -3 print(x) Ausgabe: #&gt; [-3. 3.5 1.4 0.2] 4.3.5 Skalare Multiplikation und Addition import numpy as np x = np.array([1, 4, 9, 0]) y = np.array([1, 0, 1, 0]) print(x*0.5) print(x+y) print(x-y) Ausgabe: #&gt; [0.5 2. 4.5 0. ] #&gt; [ 2 4 10 0] #&gt; [0 4 8 0] 4.3.6 Neue Rechenarten import numpy as np x = np.array([1, 4, 9, 0]) y = np.array([1, 0, 1, 0]) print(x+1) print(x*y) Ausgabe: #&gt; [ 2 5 10 1] #&gt; [1 0 9 0] 4.4 Matrix mit Numpy Matrizen werden in Numpy als eine Ansammlung von Zeilenvektoren aufgebaut! 4.4.1 Beispiel import numpy as np A = np.array([[1,2],[3,4], [5,6], [7,8]]) print( A ) print( A[0,0] ) print( A[0,1] ) Ausgabe: #&gt; [[1 2] #&gt; [3 4] #&gt; [5 6] #&gt; [7 8]] #&gt; 1 #&gt; 2 Die Indizierung der Element funktioniert erwartungsgemäß, allerdings wird mit der Zählung bei Null begonnen! 4.4.2 Shape (Dimension) Eine Matrix hat eine Anzahl von Zeilen und Spalten. Wir verwenden wie bei Vektoren shape, um die Dimension zu erfahren import numpy as np A = np.array([[1,2],[3,4], [5,6], [7,8]]) print( A.shape ) Ausgabe: #&gt; (4, 2) Die Ausgabe (4,2) besagt, dass die Matrix vier Zeilen und zwei Spalten besitzt. Allgemein gesagt, dass 4 Werte entlang der ersten Dimension und 2 Werte entlang der zweiten Dimension angeordnet werden. 4.4.3 Skalare Multiplikation und Addition import numpy as np A = np.array([[1,2],[3,4], [5,6], [7,8]]) B = np.array([[10,20],[30,40], [50,60], [70,80]]) s = 2; print (2*A) # Mulitplikation mit einem Skalar print (A+B) Ausgabe: #&gt; [[ 2 4] #&gt; [ 6 8] #&gt; [10 12] #&gt; [14 16]] #&gt; [[11 22] #&gt; [33 44] #&gt; [55 66] #&gt; [77 88]] 4.4.4 Matrixmultiplikation Die Matrixmultiplikation erfolgt über den Befehl np.dot. Wir berechnen als Beispiel folgendes Produkt (Immer auf die passenden shapes achten!): \\[ \\mathbf{A}= \\begin{bmatrix} 1 &amp; 2 \\\\ 3 &amp; 4 \\\\ 5 &amp; 6 \\end{bmatrix} \\quad\\quad\\quad \\mathbf{B}= \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 2 \\end{bmatrix} \\quad\\quad\\quad \\mathbf{A} \\mathbf{B}= \\begin{bmatrix} 1 &amp; 4 \\\\ 3 &amp; 8 \\\\ 5 &amp; 12 \\end{bmatrix} \\quad\\quad\\quad \\] Mit Numpy: np.dot() import numpy as np A = np.array([[1,2],[3,4], [5,6] ]) B = np.array([[1,0],[0,2]]) AB = np.dot(A, B) print( AB ) Ausgabe: #&gt; [[ 1 4] #&gt; [ 3 8] #&gt; [ 5 12]] 4.4.5 Übungen Lösen sie die Aufgaben aus Abschnitt 3.4 mit geeigneten Python-Programmen. sing. Datum siehe z.B. https://en.wikipedia.org/wiki/Iris_flower_data_set Quelle: https://medium.com/greyatom/using-clustering-for-feature-engineering-on-the-iris-dataset-f438366d0b4b Dabei ist noch zu konkretisieren, wie wir die Ähnlichkeit der Werte messen Es gibt natürlich noch ein paar mehr Arten von Zahlen, die wir aber hier nicht brauchen \\((\\frac{1}{n} \\sum x_i^p)^\\frac{1}{p}\\) Eine Python-Library umfasst vorgefertigte Programmen, die von Programmieren genutzt werden, um Programme schneller und sicherer zu erstellen.  Genaugenommen nur die ersten vier Spalten. Wir lassen die Spalte class weg. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
